#include<stdio.h>
#include<sys/shm.h>
#include<unistd.h>
#include<sys/mman.h>
#include<fcntl.h>
#include<string.h>
int main(){
// pipes:
// int pipe__[2];
// pipe(pipe__);
//write end pipe__[1]
//read end pipe__[0]
//u can write and read through write() and read()
//functions 


//making the shared memory segment using sys/shm.h:

//making the shared memory segment:
int id=shmget( IPC_PRIVATE, sizeof(int)* sysconf(_SC_PAGE_SIZE), 0666 );
//u can pass a key in the first argument of shmget.
//if the key passed is IPC_PRIVATE then the
//key would be generated by the function itself.
//or u can generate the key using ftok function call.

//size of the shared memory segment would be
//passed in the
//second argument of the  shmget function.
// the second argument of the shmget function
// has to be divisible by sysconf(_SC_PAGE_SIZE).
//shared memory segment permissions 
//would be passed in the
//third argument. its the same standard
//permissions in the third argument except
//  for u can not set a permission for execution.

//attaching the shared memory segment to the
//current process:
int *data= shmat(id, NULL, 0);
*data=1;
printf("\ndata is %d\n", *data);
//the id of the  memory segment( that is
//gonna be attached to the current process)
//  is passed to the first argument
//of shamt function.
//u can pass the address of where u want the 
//  memory to be in
//the second argument. passing NULL in the 
//second argument will let the kernel decide 
// on the address to put the memory in.
//u can pass flags into the third argument.
//if u pass SHM_RDONLY in the third argument
//  then it would prevent the current 
// process from writing
//into the shared memory segment
// (
// attempt to write into the shared memory segment
//  would result in a segmentation fault)

//pointer named data in our code  now points to the 
// shared  memory segment


// detaching the shared memory once we dont need it:
 shmdt( data );

//deleting the share memory once no process needs
// it:
shmctl( id, IPC_RMID, NULL );
//shmctl function can used for other purposes
//other than deleting a shared memory 
//segment too.


//creating shared memory using sys/mman:
//sys/mman libraries maps memory to a file
//mmap 
//   The first argument is the address for where 
//the mapped memory is gonna be; 
//u should set this one to NULL which would 
// let the system decide the address 
// unless you have a very
// good reason to decide the address urself. 
// The next argument is the
//  number of bytes
// we want to map. The third argument is the 
// protection rules:PROT_NONE, PROT_READ, 
// PROT_WRITE, and PROT_EXEC.
//each of these macro's can be combined 
//in the third argument using
//the OR(|) operator.
//PROT_EXEC means that the memory can be 
//executed.
//PROT_NONE would mean that the memory
// cant be accessed at all.while the rest 
//have a obvious meaning.
// whatever protection rules you choose have to be 
// consistent with how the file was opened with 
// the open function.
//  So you cant use open to open a file as readonly 
// and then 
//  somehow use mmap funtion while passing 
// PROT_WRITE in the third argument 
//and the mmaping the memory to the same
//file that u opened as readonly .
//  The flag argument 
// indicates the mode that the memory will be 
// mapped in. 
// you have two flag options. The first is MAP_PRIVATE. 
//  MAP_PRIVATE defines that:
// modifications are not visible to other processes
//that are
// mapping the same file and changes
//  are not written out to
//  the underlying file. The other is MAP_SHARED.
// MAP_SHARED defines that:
//  modifications
// are visible to other processes and are written to the
//underlying file (although perhaps not cocurrently 
//but there 
//  is msync function to make sure that it is done
//  cocurrently).
// The second-last argument is
// the file descriptor of the file that we wish to map
// our memory to.
//the file in the second-last argument has to
//be atleast of the size specified in the
//  second argument+the position specified
//in the last argument.
//u can increase the size of the file
// by putting a lot of zeros in  file
//using the write() function.
//   the last argument is the location of the area
//of the file
// to where the memory is mapped.
//the last argument has to be a multiple of
//sysconf(_SC_PAGE_SIZE).
// The return value is a pointer to the starting address
//  of the memory area where the file is mapped.


// the function used to change the protection of a 
// specific mapped address  is:
// int mprotect( void* address, size_t length, int prot );
//first argument is the address of the memory(
//  whose protection u want to change).
//second argument is the size of the memroy 
// whose protection u want to change.
//last paremeter The third argument are the new 
// protection rules:PROT_NONE, PROT_READ, 
// PROT_WRITE, and PROT_EXEC.
//each of these macro's can be combined 
//in the third argument using
//the OR(|) operator.
//PROT_EXEC means that the memory can be 
//executed.
//PROT_NONE would mean that the memory
// cant be accessed at all.while the rest 
//have a obvious meaning.
// whatever protection rules you choose have to be 
// consistent with how the file was opened with 
// the open function.
//  So you cant use open to open a file as readonly 
// and then 
//   use mmap funtion while passing 
// PROT_WRITE in the third argument 
//and the mmaping the memory to the same
//file that u opened as readonly .

//the function to make the changes to the part of file 
//(the memory is mapped to)cocurrent
//  amongst all the 
// processes  is:
// int msync( void* address, size_t length, int flags );
//first argument is the address of the memory
//that is mapped to the file.
//second  argument is the size of the memory
//mapped to the file.
//for the last argument u can pass
//  MS_SYNC. MS_SYNC would make this
//  function call  a blocking function call

// to unmap memory use:
// int munmap( void* address, size_t length );
//first argument is the address of the
//  memory that u wonna unmap.
//second argument is the size of the
//  memory that u wonna
//unmap

#define ZTPIFTIS zeros_to_put_in_file_to_increase_size
int creating_file_to_map_to = open ("shared_file__", O_WRONLY | O_CREAT, 0777);
close(creating_file_to_map_to);
int file_to_map_to= open("shared_file", O_RDWR);
char zeros_to_put_in_file_to_increase_size[1000];
memset(ZTPIFTIS, 0,1000*sizeof(char));
write(file_to_map_to, ZTPIFTIS,1000*sizeof(char) );
char *mem=mmap(NULL, 1000*sizeof(char), PROT_WRITE|PROT_READ, MAP_SHARED, file_to_map_to,0);
strcpy(mem, 
"\nthis is the data in the memory mapped to a file\n");
printf("%s", mem);
    return 0;
}